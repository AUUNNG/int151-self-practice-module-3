```js
function updateReservationStatus(data) {
    const userTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const currentStartDate = formatDateTime(data.currentPeriod.startDateTime)
    const currentEndDate = formatDateTime(data.currentPeriod.endDateTime)
    const endStartDate = formatDateTime(data.nextPeriod.startDateTime)
    const endEndDate = formatDateTime(data.nextPeriod.endDateTime)

    // ========== test ==========
    // 1                            [before current, before next]
    // 2 2025-11-25T02:00:00.000Z   [current, before next]
    // 3 2025-11-27T11:00:00.000Z   [current, before next]
    // 4                            [after current, before next]
    // 5 2025-11-28T02:00:00.000Z   [after current, next]
    // 6 2025-12-01T10:00:00.000Z   [after current, next]
    // 5                            [after current, after next]
    // ========== test ==========

    const currentTime = new Date(Date.now())
    const reservationPeriodStart = new Date(data.currentPeriod.startDateTime)
    const reservationPeriodEnd = new Date(data.currentPeriod.endDateTime)
    const nextReservationPeriodStart = new Date(data.nextPeriod.startDateTime)
    const nextReservationPeriodEnd = new Date(data.nextPeriod.endDateTime)
    let status = null

    if (currentTime >= nextReservationPeriodStart) {
        if (currentTime <= nextReservationPeriodEnd) {
            console.log("after current, next");
            status = "afterCurrentNext"
        } else {
            console.log("after current, after next");
            status = "afterCurrentAfterNext"
        }
    } else {
        if (currentTime <= reservationPeriodEnd) {
            if (currentTime >= reservationPeriodStart) {
                console.log("current, before next");
                status = "currentBeforeNext"
            } else {
                console.log("before current, before next");
                status = "beforeCurrentBeforeNext"
            }
        } else {
            console.log("after current, before next");
            status = "afterCurrentBeforeNext"
        }
    }

    switch (status) {
        case "beforeCurrentBeforeNext":
            currentMessage.textContent = "Reservation is closed"
            currentPeriod.textContent = `Period: ${currentStartDate} — ${currentEndDate} (${userTimeZone})`
            nextMessage.textContent = "Next reseration period:"
            nextPeriod.textContent = `Period: ${endStartDate} — ${endEndDate} (${userTimeZone})`
            declareActions.style.display = "none"
            declareActions.style.visibility = "hidden";
            break;

        case "currentBeforeNext":
            currentMessage.textContent = "Reservation is open"
            currentPeriod.textContent = `Period: ${currentStartDate} — ${currentEndDate} (${userTimeZone})`
            nextMessage.textContent = "Next reseration period:"
            nextPeriod.textContent = `Period: ${endStartDate} — ${endEndDate} (${userTimeZone})`
            declareActions.style.display = "grid"
            declareActions.style.visibility = "visible";
            break;

        case "afterCurrentBeforeNext":
            currentMessage.textContent = "Reservation is closed"
            nextMessage.textContent = "Next reseration period:"
            nextPeriod.textContent = `Period: ${endStartDate} — ${endEndDate} (${userTimeZone})`
            declareActions.style.display = "none"
            declareActions.style.visibility = "hidden";
            break;

        case "afterCurrentNext":
            currentMessage.textContent = "Reservation is closed"
            nextMessage.textContent = "Next reseration period:"
            nextPeriod.textContent = `Period: ${endStartDate} — ${endEndDate} (${userTimeZone})`
            declareActions.style.display = "grid"
            declareActions.style.visibility = "visible";
            break;

        case "afterCurrentAfterNext":
            currentMessage.textContent = "Reservation is closed"
            nextMessage.textContent = "There are no upcoming active reservation periods."
            declareActions.style.display = "none"
            declareActions.style.visibility = "hidden";
            break;
    }
}

function formatDateTime(data) {
    const date = new Date(data);
    const userTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone
    const dateStr = date.toLocaleString('en-GB', {
        year: 'numeric', month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit', second: '2-digit',
        hour12: false, timeZone: userTimeZone
    });
    return dateStr
}

```
ก่อนอื่นอยากเล่าครับว่า ตรง if (condition) ก่อนหน้านี้ไม่ได้เป็นหน้าตาแบบนี้เละมาก่อน logic ไม่ได้ตามที่ต้องการเป็น condition ยาวๆ แต่ก็ทำไม่ตรงตามที่ต้องการ
และก็ได้เปลี่ยนรูปแบบการเขียน ลักษณะนี้ ได้จาก อาจารย์ เกรียงไกร สอนครับ และก่อนหน้านี้ก็นำ DOM ยัดเข้าไป ซึ่งรู้สึกว่า maintain ยาก
จึงแยกมาใส่ใน switch case เพราะรู้สึกว่าในอนาคตนี้จะต้องมีการเล่น DOM เกี่ยวกับเวลามากขึ้น เลยแยกไว้เพื่อรองรับ
โดย switch case แบ่งเป็น 5 status หลักจากลอง test ก็ได้แบบที่ต้องการครับ

// 1                            [before current, before next]
// 2 2025-11-25T02:00:00.000Z   [current, before next]
// 3 2025-11-27T11:00:00.000Z   [current, before next]
// 4                            [after current, before next]
// 5 2025-11-28T02:00:00.000Z   [after current, next]
// 6 2025-12-01T10:00:00.000Z   [after current, next]
// 5                            [after current, after next]

ณ ตอนนี้ก็ยังอยู่ pbi แรกของ sprint ครับ ยังไม่ได้ไปไหนไกลครับ
